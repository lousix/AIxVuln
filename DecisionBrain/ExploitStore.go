package DecisionBrain

import (
	"AIxVuln/misc"
	"AIxVuln/taskManager"
	"database/sql"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	_ "modernc.org/sqlite"
)

type ExploitStore struct {
	projectName string
	db          *sql.DB
	mu          sync.Mutex
}

func NewExploitStore(projectName string) (*ExploitStore, error) {
	projectDir := filepath.Join(misc.GetDataDir(), "projects", projectName)
	memoryDir := filepath.Join(projectDir, "memory")
	if err := os.MkdirAll(memoryDir, 0755); err != nil {
		return nil, err
	}
	dbPath := filepath.Join(memoryDir, "exploits.db")
	db, err := sql.Open("sqlite", dbPath)
	if err != nil {
		return nil, err
	}
	db.SetMaxOpenConns(1)
	db.SetMaxIdleConns(1)

	s := &ExploitStore{projectName: projectName, db: db}
	if err := s.migrate(); err != nil {
		_ = db.Close()
		return nil, err
	}
	return s, nil
}

func (s *ExploitStore) migrate() error {
	stmts := []string{
		`PRAGMA journal_mode=WAL;`,
		`CREATE TABLE IF NOT EXISTS exploit_idea (
			id TEXT PRIMARY KEY,
			state TEXT NOT NULL,
			harm TEXT,
			condition TEXT,
			title TEXT,
			type TEXT,
			file TEXT,
			route TEXT,
			updated_at INTEGER NOT NULL,
			json TEXT NOT NULL
		);`,
		`CREATE INDEX IF NOT EXISTS idx_exploit_idea_search ON exploit_idea (state, harm, condition, title, type, file, route);`,
		`CREATE TABLE IF NOT EXISTS exploit_chain (
			id TEXT PRIMARY KEY,
			state TEXT NOT NULL,
			idea TEXT,
			updated_at INTEGER NOT NULL,
			json TEXT NOT NULL
		);`,
		`CREATE INDEX IF NOT EXISTS idx_exploit_chain_search ON exploit_chain (state, idea);`,
	}
	for _, stmt := range stmts {
		if _, err := s.db.Exec(stmt); err != nil {
			return err
		}
	}
	return nil
}

func (s *ExploitStore) Close() error {
	if s == nil || s.db == nil {
		return nil
	}
	return s.db.Close()
}

func (s *ExploitStore) UpsertExploitableIdea(e *taskManager.ExploitIdea) error {
	if s == nil || s.db == nil {
		return fmt.Errorf("nil store")
	}
	if e == nil {
		return fmt.Errorf("nil exploitIdea")
	}
	if strings.TrimSpace(e.ExploitIdeaId) == "" {
		return fmt.Errorf("empty exploitIdeaId")
	}

	js, err := json.Marshal(e)
	if err != nil {
		return err
	}

	title := ""
	typ := ""
	file := ""
	route := ""
	if e.ExploitPoint != nil {
		title = e.ExploitPoint.Title
		typ = e.ExploitPoint.Type
		file = e.ExploitPoint.File
		route = e.ExploitPoint.RouteOrEndpoint
	}

	now := time.Now().Unix()
	s.mu.Lock()
	defer s.mu.Unlock()
	_, err = s.db.Exec(
		`INSERT INTO exploit_idea(id, state, harm, condition, title, type, file, route, updated_at, json)
		 VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
		 ON CONFLICT(id) DO UPDATE SET
		 state=excluded.state,
		 harm=excluded.harm,
		 condition=excluded.condition,
		 title=excluded.title,
		 type=excluded.type,
		 file=excluded.file,
		 route=excluded.route,
		 updated_at=excluded.updated_at,
		 json=excluded.json;`,
		e.ExploitIdeaId,
		e.State,
		e.Harm,
		e.Condition,
		title,
		typ,
		file,
		route,
		now,
		string(js),
	)
	return err
}

func (s *ExploitStore) UpsertExploitableChain(ec *taskManager.ExploitChain) error {
	if s == nil || s.db == nil {
		return fmt.Errorf("nil store")
	}
	if ec == nil {
		return fmt.Errorf("nil exploitChain")
	}
	if strings.TrimSpace(ec.ExploitChainId) == "" {
		return fmt.Errorf("empty exploitChainId")
	}

	js, err := json.Marshal(ec)
	if err != nil {
		return err
	}

	now := time.Now().Unix()
	s.mu.Lock()
	defer s.mu.Unlock()
	_, err = s.db.Exec(
		`INSERT INTO exploit_chain(id, state, idea, updated_at, json)
		 VALUES(?, ?, ?, ?, ?)
		 ON CONFLICT(id) DO UPDATE SET
		 state=excluded.state,
		 idea=excluded.idea,
		 updated_at=excluded.updated_at,
		 json=excluded.json;`,
		ec.ExploitChainId,
		ec.State,
		ec.Idea,
		now,
		string(js),
	)
	return err
}

type ExploitIdeaSearchRow struct {
	ExploitIdeaId string `json:"exploitIdeaId"`
	State         string `json:"state"`
	Harm          string `json:"harm"`
	Condition     string `json:"condition"`
	Title         string `json:"title"`
	Type          string `json:"type"`
	File          string `json:"file"`
	Route         string `json:"route_or_endpoint"`
	UpdatedAt     int64  `json:"updated_at"`
}

func (s *ExploitStore) SearchExploitableIdeas(query string, limit int) ([]ExploitIdeaSearchRow, error) {
	if s == nil || s.db == nil {
		return nil, fmt.Errorf("nil store")
	}
	if limit <= 0 || limit > 100 {
		limit = 20
	}
	q := strings.TrimSpace(query)
	pattern := "%" + q + "%"

	s.mu.Lock()
	defer s.mu.Unlock()
	var rows *sql.Rows
	var err error
	if q == "" {
		rows, err = s.db.Query(
			`SELECT id, state, harm, condition, title, type, file, route, updated_at
			 FROM exploit_idea
			 WHERE state = '可利用'
			 ORDER BY updated_at DESC
			 LIMIT ?;`,
			limit,
		)
	} else {
		rows, err = s.db.Query(
			`SELECT id, state, harm, condition, title, type, file, route, updated_at
			 FROM exploit_idea
			 WHERE state = '可利用' AND (
				 harm LIKE ? OR condition LIKE ? OR title LIKE ? OR type LIKE ? OR file LIKE ? OR route LIKE ? OR json LIKE ?
			 )
			 ORDER BY updated_at DESC
			 LIMIT ?;`,
			pattern, pattern, pattern, pattern, pattern, pattern, pattern,
			limit,
		)
	}
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	out := make([]ExploitIdeaSearchRow, 0)
	for rows.Next() {
		var r ExploitIdeaSearchRow
		if err := rows.Scan(&r.ExploitIdeaId, &r.State, &r.Harm, &r.Condition, &r.Title, &r.Type, &r.File, &r.Route, &r.UpdatedAt); err != nil {
			return nil, err
		}
		out = append(out, r)
	}
	return out, rows.Err()
}

func (s *ExploitStore) GetExploitableIdeaJSONById(id string) (string, error) {
	if s == nil || s.db == nil {
		return "", fmt.Errorf("nil store")
	}
	id = strings.TrimSpace(id)
	if id == "" {
		return "", fmt.Errorf("empty id")
	}

	s.mu.Lock()
	defer s.mu.Unlock()
	var js string
	err := s.db.QueryRow(`SELECT json FROM exploit_idea WHERE id = ? AND state = '可利用' LIMIT 1;`, id).Scan(&js)
	if err != nil {
		return "", err
	}
	return js, nil
}

 func (s *ExploitStore) GetExploitableChainJSONById(id string) (string, error) {
	if s == nil || s.db == nil {
		return "", fmt.Errorf("nil store")
	}
	id = strings.TrimSpace(id)
	if id == "" {
		return "", fmt.Errorf("empty id")
	}

	s.mu.Lock()
	defer s.mu.Unlock()
	var js string
	err := s.db.QueryRow(`SELECT json FROM exploit_chain WHERE id = ? AND state = '可利用' LIMIT 1;`, id).Scan(&js)
	if err != nil {
		return "", err
	}
	return js, nil
 }
