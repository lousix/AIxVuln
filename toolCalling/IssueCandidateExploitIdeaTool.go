package toolCalling

import (
	"AIxVuln/taskManager"
	"encoding/json"
	"fmt"
)

type IssueCandidateExploitIdeaTool struct {
	task *taskManager.Task
}

func NewIssueCandidateExploitIdeaTool(task *taskManager.Task) *IssueCandidateExploitIdeaTool {
	return &IssueCandidateExploitIdeaTool{task: task}
}

func (h *IssueCandidateExploitIdeaTool) Name() string {
	return "IssueCandidateExploitIdeaTool"
}
func (h *IssueCandidateExploitIdeaTool) Description() string {
	return "Use this tool to record a discovered exploitIdea (a composable exploitation primitive; not necessarily a standalone vulnerability)."
}
func (h *IssueCandidateExploitIdeaTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"harm": map[string]interface{}{
				"type":        "string",
				"description": "Harm of the exploit point (what it can achieve)",
			},
			"extend_idea": map[string]interface{}{
				"type":        "string",
				"description": "Extended exploitation ideas (what can be done with it to better meet researcher requirements)",
			},
			"condition": map[string]interface{}{
				"type":        "string",
				"description": "Exploitation conditions",
			},
			"exploit_point": map[string]interface{}{
				"type": "object",
				"properties": map[string]interface{}{
					"confidence": map[string]interface{}{
						"type":        "string",
						"description": "Confidence level of the vulnerability",
					},
					"expected_impact": map[string]interface{}{
						"type":        "string",
						"description": "Expected impact of successful exploitation",
					},
					"file": map[string]interface{}{
						"type":        "string",
						"description": "File path where the vulnerability exists",
					},
					"function_or_method": map[string]interface{}{
						"type":        "string",
						"description": "Function or method name containing the vulnerability",
					},
					"params": map[string]interface{}{
						"type":        "string",
						"description": "Parameters formatted as (delivery_method->parameter_name, delivery_method->parameter_name). Example: header->a,cookie->b,post->c",
					},
					"payload_idea": map[string]interface{}{
						"type":        "string",
						"description": "Payload construction ideas for exploitation",
					},
					"route_or_endpoint": map[string]interface{}{
						"type":        "string",
						"description": "Route or API endpoint where the vulnerability can be triggered",
					},
					"title": map[string]interface{}{
						"type":        "string",
						"description": "Title of the vulnerability (write in Chinese)",
					},
					"type": map[string]interface{}{
						"type":        "string",
						"description": "Vulnerability type abbreviation in uppercase (e.g., SQLI, XSS, IDOR, XXE, etc.)",
					},
					"exploit_id": map[string]interface{}{
						"type":        "string",
						"description": "Unique identifier for the exploit point",
					},
				},
				"required": []string{
					"title",
					"route_or_endpoint",
					"file",
					"function_or_method",
					"params",
					"type",
					"payload_idea",
					"expected_impact",
					"confidence",
				},
				"description": "Specific information about the exploit point",
			},
		},
		"required": []string{"harm", "extend_idea", "condition", "exploit_point"},
	}
}

func (h *IssueCandidateExploitIdeaTool) Execute(parameters map[string]interface{}) string {
	// Hard quota check: reject if per-task submission limit reached.
	quota := h.task.GetExploitIdeaQuota()
	if quota > 0 && h.task.GetExploitIdeaSubmitted() >= quota {
		return Fail(fmt.Sprintf("Per-task exploitIdea quota reached (%d/%d). Stop mining and call AgentFinishTool to wrap up.", h.task.GetExploitIdeaSubmitted(), quota))
	}
	c, err := json.Marshal(parameters)
	if err != nil {
		return Fail(err.Error())
	}
	exploitIdea := &taskManager.ExploitIdea{}
	err = json.Unmarshal(c, exploitIdea)
	if err != nil {
		return Fail(err.Error())
	}
	err = h.task.GetCandidateExploitIdeaHandler()(exploitIdea)
	if err != nil {
		return Fail(err.Error())
	}
	h.task.IncrementExploitIdeaSubmitted()
	h.task.AddKeyMessage("ExploitIdeaDiscovered", exploitIdea, true)
	remaining := ""
	if quota > 0 {
		remaining = fmt.Sprintf(" (%d/%d for this task)", h.task.GetExploitIdeaSubmitted(), quota)
	}
	return Success("success" + remaining)
}
