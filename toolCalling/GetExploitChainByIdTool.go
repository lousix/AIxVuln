package toolCalling

import (
	"AIxVuln/taskManager"
	"encoding/json"
)

type GetExploitChainByIdTool struct {
	task *taskManager.Task
}

func NewGetExploitChainByIdTool(task *taskManager.Task) *GetExploitChainByIdTool {
	return &GetExploitChainByIdTool{task: task}
}

func (h *GetExploitChainByIdTool) Name() string {
	return "GetExploitChainByIdTool"
}
func (h *GetExploitChainByIdTool) Description() string {
	return "Retrieve the full details of an ExploitChain by its ID (e.g. 'C.0'). Returns the complete chain information including constituent exploit ideas, evidence, PoC, etc."
}
func (h *GetExploitChainByIdTool) Parameters() map[string]interface{} {
	return map[string]interface{}{
		"type": "object",
		"properties": map[string]interface{}{
			"exploitChainId": map[string]interface{}{
				"type":        "string",
				"description": "The exploitChainId to look up, e.g. 'C.0'.(required)",
			},
		},
	}
}

func (h *GetExploitChainByIdTool) Execute(parameters map[string]interface{}) string {
	idTemp := parameters["exploitChainId"]
	if idTemp == nil {
		return Fail("Missing 'exploitChainId' parameter")
	}
	id, ok := idTemp.(string)
	if !ok || len(id) < 2 {
		return Fail("Invalid exploitChainId")
	}
	getter := h.task.GetExploitChainGetter()
	if getter == nil {
		return Fail("ExploitChain getter not available")
	}
	chain, err := getter(id)
	if err != nil {
		return Fail(err.Error())
	}
	js, _ := json.Marshal(chain)
	return Success(string(js))
}
